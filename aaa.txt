(	
	-- Duplicate hierarchical object as instance
	fn CloneInstanceHierarchy obj parentNode:undefined prefix:"Inst_" =
	(
		-- 1. Create reference
		local newObj = instance obj
		newObj.name = prefix + obj.name + "_" + obj.inode.handle as String
		
		-- 2. Set parent if specified
		if parentNode != undefined do
			newObj.parent = parentNode
		newObj.isFrozen = true
		newObj.showFrozenInGray  = false
		
		-- 3. Process all children
		for child in obj.children do
		(
			CloneInstanceHierarchy child parentNode:newObj
		)
		
		return newObj
	)


	-- 実行部分
	if selection.count > 0 then
	(
		with undo off
		(
			-- 選択されたトップノードから開始			
			CloneInstanceHierarchy selection[1]
		)
	)
	else
	(
		messageBox "オブジェクトを選択してください。"
	)
)









(
    -- 1. 対象のオブジェクトを取得（モディファイヤ適用後の「現在の状態」をメッシュとして取得）
    local obj = selection[1]
    local density = 1 -- 密度設定
    
    if (isValidNode obj) then
    (
        -- snapshotAsMeshで、現在のスタック状態の三角形メッシュをメモリ上に生成
        local tempMesh = snapshotAsMesh obj
        local numFaces = tempMesh.numfaces
        local totalPoints = 0
        
        undo "Distribute Points Universal" on
        (
            for f = 1 to numFaces do
            (
                -- 三角形の面積を計算（meshOpではなく、直接Faceの頂点から計算）
                local vidx = getFace tempMesh f
                local vA = getVert tempMesh vidx.x
                local vB = getVert tempMesh vidx.y
                local vC = getVert tempMesh vidx.z
                
                -- 外積を用いて三角形の面積を求める（面積 = |(B-A) x (C-A)| / 2）
                local fArea = 0.5 * (length (cross (vB - vA) (vC - vA)))
                
                -- 配置する点数を決定
                local numPointsInFace = (fArea * density) as integer
                -- 密度が低い場合に備え、確率で1つ配置するか判定（オプション）
                if ((fArea * density) - numPointsInFace) > random 0.0 1.0 do numPointsInFace += 1
                
                for i = 1 to numPointsInFace do
                (
                    local r1 = random 0.0 1.0
                    local r2 = random 0.0 1.0
                    local sqrtR1 = sqrt r1
                    
                    local pos = (1 - sqrtR1) * vA + (sqrtR1 * (1 - r2)) * vB + (sqrtR1 * r2) * vC
                    
                    -- 法線方向（配置した点の上方向）も取得可能
                    local fNormal = getFaceNormal tempMesh f
                    point pos:pos dir:fNormal size:0.1 wirecolor:white
                    
                    totalPoints += 1
                )
            )
        )
        -- メモリ解放
        delete tempMesh
        format "汎用配置完了: % 個のポイントを作成しました。\n" totalPoints
    )
    else (messageBox "オブジェクトを選択してください。")
)







(
	global rollout_SortManager
	try(destroyDialog rollout_SortManager)catch()

	rollout rollout_SortManager "Object Sorter" --width:240
	(
		local margin = 5
		local btnSize = 25
		
		-- オブジェクト保持用配列
		local pickedObjects = #()
		
		button btn_add "Add" across:2
		button btn_remove "Remove"
		
		listbox lbx_objects "リスト:"  --across:3 ---width:150 height:10
		button btn_up "▲" width:btnSize height:btnSize pos:[150, 50]
		button btn_down "▼" width:btnSize height:btnSize pos:[150, 80]

		
		 -- レイアウト更新関数
		fn updateLayout =
		(	
			local w = rollout_SortManager.width
			local h = rollout_SortManager.height
			
			lbx_objects.width = w - btnSize - margin*4
			
			btn_up.pos = [ lbx_objects.pos.x + lbx_objects.width + margin, lbx_objects.pos.y ]
			btn_down.pos = [ btn_up.pos.x, btn_up.pos.y + btnSize + margin ]
		
		)	
		
		-- UI更新用関数
		fn updateUI = (
			lbx_objects.items = for o in pickedObjects where isValidObj o collect o.name
		)

		
		on btn_add pressed do
		(
			local currSel = selection as array
			for obj in currSel do ( appendIfUnique pickedObjects obj )
			 updateUI()
		)
		
		
		on btn_remove pressed do
		(
			local idx = lbx_objects.selection
			if idx > 0 do
			(
				deleteItem pickedObjects idx
				updateUI()
			)
		)	
		
		on btn_up pressed do
		(
			local idx = lbx_objects.selection
			if idx > 1 do -- Execute if not first element
			(
				swap pickedObjects[idx] pickedObjects[idx - 1]
				updateUI()
				lbx_objects.selection = idx - 1 -- Follow row selection
			)
		)

		on btn_down pressed do
		(
			local idx = lbx_objects.selection
			if idx > 0 and idx < pickedObjects.count do  -- Execute if not last element
			(
				swap pickedObjects[idx] pickedObjects[idx + 1]
				updateUI()
				lbx_objects.selection = idx + 1 -- Follow row selection
			)
		)
		
	
	on rollout_SortManager open do updateLayout()	
	--on rollout_SortManager resized size do updateLayout()	
		
		
	)
	createDialog rollout_SortManager
)