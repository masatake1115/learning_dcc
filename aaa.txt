-- ==========================================
-- カスタムアトリビュート定義
-- ==========================================
Offset_Attributes = attributes "OffsetPro"
(
	-- ==========================================
	-- Parameters and member variables
	-- ==========================================	
	
	local callbackHandler = undefined
	local workObj = undefined
	local resultNode = undefined -- オフセット結果のノードを保持
	
	
	
	parameters main rollout:params
	(
		------------ GUI parameter values -----------
		thresh type:#float ui:spn_thresh default:0.1
		iters type:#integer ui:spn_iters default:2
		
		offset_Horizontal  type:#float ui:spn_offset_h default:10.0
		offset_Vertical  type:#float ui:spn_offset_v default:0.0
		
		
		
		----- Max objects(refernces tpo ther nodes) ----
		refResultNode type:#maxObject
		refWorkObj type:#maxObject
		
		neesReset type:#boolean default:false -- on clone detection flag to reset maxcObject
		
		
		
		CA_ID type:#integer default:123456789
	)
	
	
	
	
	-- ==========================================
	-- Utility functions
	-- ==========================================

	-- signed area computation（ to detect inside/outside by sign）
	--fn getSplineArea obj spl =
	--(
	--	local area = 0.0
	--	local n = numKnots obj spl
	--	for i = 1 to n do (
	--		local p1 = getKnotPoint obj spl i
	--		local p2 = if i == n then getKnotPoint obj spl 1 else getKnotPoint obj spl (i + 1)
	--		area += (p1.x * p2.y) - (p2.x * p1.y)
	--	)
	--	area * 0.5
	--)


	--global adaptiveResampleSpline_CornerSafe
	fn adaptiveResampleSpline_CornerSafe obj spl threshold:0.1 iterations:3 =
	(
		
		-- 1. 全ての頂点をBezier化し、ハンドルをノット位置にリセットする
		-- これにより、Corner頂点による「強制的な直線化」を防ぎつつ、形状を維持できる
		local nKnots = numKnots obj spl
		for k = 1 to nKnots do
		(
			local p = getKnotPoint obj spl k
			local curr_knot_type = getKnotType obj spl k
			-- 元々のタイプを問わず、一旦Bezierへ
			--setKnotType obj spl k #bezier
			-- ハンドル長を0にする（ノット位置と一致させる）
			-- これで「見た目」はCornerやLinearセグメントのまま、内部的にサンプリング可能になる
			if curr_knot_type == #corner then
			(
				--setInVec obj spl k p
				--setOutVec obj spl k p
			)
			else if curr_knot_type == #smooth then
			(
				setKnotType obj spl k #bezier		
			)
			
		)
		
		-- 2. セグメントをCurveに変更（サンプリング精度を確保するため）
		local nSegs = numSegments obj spl
		for s = 1 to nSegs do
		(
			setSegmentType obj spl s #curve
		)
		
		--TODO: handle closed curve
		
		-- 3. Do Adaptive refinement
		for i = 1 to iterations do
		(
			local is_closed = isClosed obj spl
			local currentSegs = numSegments obj spl
			local num_knots = numKnots obj spl
			
			local numSegs =  (numSegments obj spl) + (if is_closed then 1 else 0)
			
			format "iter %: numSegs: %\n" i numSegs
			local j = 0
			while j < numSegs do
			(
				local s = j+1
				local s_next = mod (j+1) (num_knots) + 1
				
				--format "    iter %: seg %\n" j s
				-- 実際のパス上の座標を取得
				local midPointActual = interpBezier3D obj spl s 0.5
				
				
				-- 直線的な中間点を計算
				local p1 = getKnotPoint obj spl s
				local p2 = getKnotPoint obj spl s_next
				--format "    p1: %\n" p1
				--format "    p2: %\n" p2

				local midPointLinear = (p1 + p2) * 0.5
				local dist = distance midPointActual midPointLinear
				
				--format "    midPointLinear: %\n" midPointLinear
				--format "    midPointActual: %\n" midPointActual				
				--format "     suvdivide: %\n" (dist > threshold)
				-- 曲率（歪み）がある場合のみ分割
				if dist > threshold then
				(
					--format "subdividing segment %...\n" s
					refineSegment obj spl s 0.5
					-- refineSegmentで追加された頂点も、自動的に前後のBezier性を引き継ぐ
					j += 2
					numSegs += 1
					num_knots+=1
				)
				else
				(
					j +=1
				)
				--print "----------------------\n"				

			) --end of i loop
			
		) --
		
		/*
		-- 4. クリーンアップ：ハンドル長が0の場所（直線部分）をCornerに戻す
		-- これにより、ユーザーが後でGUIで編集しやすいデータに戻る
		updateShape obj -- 一旦更新して座標を確定
		local finalKnots = numKnots obj spl
		for k = 1 to finalKnots do
		(
			local p = getKnotPoint obj spl k
			local inV = getInVec obj spl k
			local outV = getOutVec obj spl k
			
			-- ハンドルがノットとほぼ同位置ならCornerに戻す
			if (distance p inV < 0.0001) and (distance p outV < 0.0001) do
			(
				setKnotType obj spl k #corner
			)
		)
		*/
		updateShape obj
	)	


	--global OverwriteSplines
	fn OverwriteSplines sourceObj targetObj =
	(
		print "+++++++++++++++++++++++++++++-----\n"
		
		if (not isValidNode sourceObj) or (not isValidNode targetObj) do return false
		
		
		
		-- Clear existing splines from targetObj
		while (numSplines targetObj) > 0 do deleteSpline targetObj 1
		
		-- Copy spline fr
		local num_splines = numSplines sourceObj
		for s=1 to num_splines do
		(
			-- Add new spline
			local newSplineIdx = addNewSpline targetObj

			-- Copy knots from sourceObj
			is_closed = isClosed sourceObj s
			num_knots = numKnots sourceObj s
				
			for k = 1 to num_knots do
			(	
				local k_seg = mod (k-1) (num_knots-1) + 1 --knot segtype acces index to avoid out of range index.

				local kType = getKnotType sourceObj s k
				local lType = getSegmentType sourceObj s k_seg
				local kPos = getKnotPoint sourceObj s k
				local inVec = getInVec sourceObj s k
				local outVec = getOutVec sourceObj s k
				
				case kType of
				(
					#corner			: addKnot targetObj newSplineIdx kType lType kPos
					default			: addKnot targetObj newSplineIdx kType lType kPos inVec outVec
				)	
				
			)-- end of k loop
			
			-- Apply closed flag
			if is_closed do close targetObj newSplineIdx
			
		) --end of s loop

		updateShape targetObj	
		
	) -- end of OverwriteSplines
		
		

	
	fn getResultNode = 
	(
		--format "  fn getResultNode   %\n" refResultNode
		if refResultNode != undefined and isProperty refResultNode #node then
		(
			--format "getResultNode %\n" refResultNode.node
			refResultNode.node
		)
		else
		(
			--format "getResultNode %\n" undefined
			undefined
		)
	)	
		
	
	fn setResultNode theNode =
	(
        -- nodeTransformMonitorで包むことで、循環参照エラーを回避しつつ参照を維持
        refResultNode = nodeTransformMonitor node:theNode forwardTransformMessages:false
		--format "  fn setResultNode   % %\n" theNode refResultNode
    )	
	
	fn validateResultNode =
	(
		local masterNode =  (refs.dependentNodes (custAttributes.getOwner this))[1]
		local res = getResultNode()
		
		if res == undefined do
		(
			format "refResultNode does not have item. % %\n" masterNode res
			setResultNode undefined
			return false
		)
		
		if res.parent != masterNode do
		(
			format "incorrect child. resetting refResultNode. % %\n" masterNode res
			setResultNode undefined
		)	
		
	)
	
	

	fn getWorkObj = 
	(
		if refWorkObj != undefined and isProperty refWorkObj #node then
			refWorkObj.node
		else
			undefined
	)	
	
	
	fn setWorkObj theNode = (  refWorkObj = nodeTransformMonitor node:theNode forwardTransformMessages:false )		
	
	
	fn validateWorkObj =
	(
		local masterNode =  (refs.dependentNodes (custAttributes.getOwner this))[1]
		local res = getWorkObj()
			
		if res == undefined do
		(
			format "refWorkObj does not have item. % %\n" masterNode res
			setWorkObj undefined
			return false
		)
		
		if res.parent != masterNode do
		(
			format "incorrect child. resetting refWorkObj. % %\n" masterNode res
			setWorkObj undefined
		)
	)
	
	
	fn SAFE_RESET_MAX_OBJS =
	(
		if this.neesReset==true do
		(
			print "SAFE_RESET_MAX_OBJS()...\n"
			
			setWorkObj undefined
			setResultNode undefined

			this.neesReset = false
		)
	)	
	
	
	
	
	
	on create do
	(
		print "on create...\n"
	)
	

	on postCreate do
	(
		print "on postCreate...\n"
	)
	
	
	
	on clone orig do
	(
		format "on clone ...\n"		
		this.neesReset = true
		
		this.workObj = undefined 
		this.resultNode = undefined 
	)
	
	
	
	fn createCurve masterNode =
	(
		format "createCurve ++++++++++++++++++++ resultNode %\n" resultNode
		
		if isValidNode workObj do delete workObj
		workObj = splineShape name:(masterNode.name + "_workObj")
		workObj.parent = masterNode
		workObj.isHidden = true -- hide workingdata
		workObj.isFrozen = false	
		setWorkObj workObj
		
		if isValidNode resultNode do delete resultNode
		resultNode = splineShape name:(masterNode.name + "_offset")
		resultNode.parent = masterNode
		setResultNode resultNode
		
		--format "  resultNode: %\n" resultNode
					
		select masterNode
		
	)
	
	
	
	-- メインの計算関数
	fn updateOffset masterNode =
	(
		--format "-------------------- updateOffset ----------\n"
		
		if not (isValidNode masterNode and isValidNode resultNode) do return false
		
		
		with redraw off
		(
			-- Reset result node's existing splines
			while (numSplines resultNode) > 0 do deleteSpline resultNode 1
			OverwriteSplines masterNode workObj			
			resultNode.wirecolor = color 255 200 0 -- set color
			
			for s = 1 to (numSplines workObj) do
			(
				adaptiveResampleSpline_CornerSafe workObj s threshold:thresh iterations:iters 
				
				-- 2. 内外判定とオフセット実行
				local finalDist = offset_Horizontal
				
				addNewSpline resultNode
				local finalKnots = numKnots workObj s
				local is_closed = isClosed workObj s
				
				for k = 1 to finalKnots do
				(
					local knot_k = amin k (finalKnots-1)
					--format "% % %\n" finalKnots k knot_k
					local percent = float(k-1) / (if is_closed then finalKnots else (finalKnots-1))
					--percent = amin percent 0.99
					

					local knot_type = getKnotType workObj s k						-- #corner  #smooth   #bezier
					local segment_type = getSegmentType workObj s knot_k 	-- #line       #curve
					
					local p = getKnotPoint workObj s k
					local t = normalize( pathTangent workObj s percent )
					local n = normalize (cross t [0,0,1])
					
					-- Correct extrusion offset according to corner angle --
					local delta = 0.01
					local t_in = normalize( pathTangent workObj s (amax 0.01 (percent-delta)) )
					
					local cos_theta = dot n t_in
					local sin_theta = sqrt (1.0 - cos_theta * cos_theta)
					local offset = n * (finalDist / (amax sin_theta 1.0e-5)) + [0,0,offset_Vertical]
					--local offset = n * finalDist

						
					local inV = (getInVec workObj s k) + offset
					local outV = (getOutVec workObj s k) + offset
					
					--if knot_type != #corner do
					(
						inV = (getInVec workObj s k) + offset
						 outV = (getOutVec workObj s k) + offset
					)
						
						
					case knot_type of
					(
						#corner			: addKnot resultNode s knot_type segment_type (p + offset)
						default			: addKnot resultNode s knot_type segment_type (p + offset) inV outV
					)
					--addKnot resultNode s knot_type segment_type (p + offset)
					--setInVec resultNode s s inV
					--setOutVec resultNode s s outV
					
					
				)-- end of k loop
				
				if isClosed workObj s do close resultNode s
				
			) --end of s loop
			
			updateShape resultNode
			
		)-- end of redraw off
		
		
	) -- end of updateOffset

	
	
	
	rollout params "Offset Pro Controls"
	(
		label lbl_offsets_begin			"---------- Offsets ---------"
		spinner spn_offset_h "Horizontal" range:[-1.0e+9,1.0e+9, 0]
		spinner spn_offset_v "Vertical" range:[-1.0e+9,1.0e+9, 0]
		label lbl_offsets_end			""
		
		label lbl_curve_sampling		"----- Curve Sampling -----"
		spinner spn_thresh "Accuracy: " range:[0.001,10.0,0.1]
		spinner spn_iters "Samples: " range:[0,6,3] type:#integer
		label lbl_curve_sampling_end	""
		
		button btn_create "Create" across: 2
		button btn_del "Remove"

		
		
			
		on spn_offset_h changed val do updateOffset (refs.dependentNodes (custAttributes.getOwner this))[1]
		on spn_offset_v changed val do updateOffset (refs.dependentNodes (custAttributes.getOwner this))[1]
			
		on spn_thresh changed val do updateOffset (refs.dependentNodes (custAttributes.getOwner this))[1]
		on spn_iters changed val do updateOffset (refs.dependentNodes (custAttributes.getOwner this))[1]
		on btn_del pressed do ( if isValidNode resultNode do delete resultNode if isValidNode workObj do delete workObj )
		
		on btn_create pressed do
		(
			local masterNode =  (refs.dependentNodes (custAttributes.getOwner this))[1]
			createCurve masterNode
			updateOffset masterNode
		)
			

		
			
		-- ロールアウトが開いたとき（修正パネルを選択したとき）にコールバックを開始
		on params open do
		(
			SAFE_RESET_MAX_OBJS()
			
			resultNode = getResultNode()
			workObj = getWorkObj()
			
			format "on params open...%\n" (getResultNode())-- refResultNode
			
			--local owner = (refs.dependentNodes (custAttributes.getOwner this))[1]
			--format "owner handle: %\n" (getHandleByAnim owner)
				
			/*
			fn doUpdate ev nd =
			(
				Compile error: No outer local variable references permitted here:  owner
				if isValidNode owner do this.updateOffset owner
			)
			
			if isValidNode owner do
			(
				-- 頂点の変更を監視するコールバックを登録
				callbackHandler = NodeEventCallback mouseUp:true geometryChanged:doUpdate topologyChanged:doUpdate
			)				
			*/
			
			
			fn doUpdate ev nodes =
			(
				--print("doUpdate!!!\n")
				for h in nodes do
				(
					local masterNode = getAnimByHandle h
					--format "... %\n" masterNode
					
					for m in masterNode.modifiers do
					(
						if isProperty m #OffsetPro do
						(
							--print "found target spline !!!"
							m.OffsetPro.updateOffset masterNode
							forceCompleteRedraw()
						)
					)
					
				)
			)
			
			print "(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\n"
			
			callbackHandler = undefined  --Unregister callback
			gc light:true -- Cleanup memory
			callbackHandler = NodeEventCallback mouseup:true geometryChanged:doUpdate topologyChanged:doUpdate
			
			callbacks.removeScripts id:#OreOreClone
			
			global OffsetCurvePreDelete
			fn OffsetCurvePreDelete =
			(
				--format "MyPreDeleted......+++++++++\n"
								
				-- Get this modifier
				local me = (callbacks.notificationParam())[2] -- #(node, modifier)
				
				-- Do removal process if THIS CA
				if isProperty me #CA_ID do
				(
					local theCA = custAttributes.get me  1
					
					-- Delete working data
					--print theCA.workObj
					if isValidNode theCA.workObj do delete theCA.workObj
					if isValidNode theCA.resultNode do delete theCA.resultNode
					
					-- Unregister callback handler
					theCA.callbackHandler = undefined
					gc light:true				
					
					--print "OffsetCurvePreDelet...\n"
				)

			)
			
			callbacks.addScript #preModifierDeleted "OffsetCurvePreDelete()" id:#OreOreClone persistent:false
			
			
			print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n"
			/*
			global OffsetCurvePostAdd
			fn OffsetCurvePostAdd =
			(
				print "OffsetCurvePostAdd()...\n"
				-- Get this CA
				local me = (callbacks.notificationParam())[2] -- #(node, modifier)
				local theCA = custAttributes.get me 1
				
				--format "  owner handle: %\n" (getHandleByAnim me)
					
				--format "  theCA: %\n" theCA
				--theCA.workObj = undefined
				--theCA.resultNode = undefined
				
				-- Unregister callback handler
				--theCA.callbackHandler = undefined
				--gc light:true
				
			)
			
			callbacks.addScript #postModifierAdded "OffsetCurvePostAdd()" id:#OreOreClone persistent:false
			*/
			
			
			
		) -- end of on params open
		
		
		
		-- ロールアウトが閉じたとき（選択解除など）にコールバックを削除して重くなるのを防ぐ
		on params close do
		(
			print "on params close...\n"

		) -- end of on params close
		
	)
	
	
)










-- 選択したスプラインに適用
if selection.count == 1 and superClassOf $ == shape then
(
	undo "SetupOffsetCurveAttrib" on
	(
		local theMod = EmptyModifier()
		theMod.name = "Clone Offset Curve"
		addModifier $ theMod	
		custAttributes.add theMod Offset_Attributes
		max modify mode
		
	)
)
else
(
	messageBox "スプラインを1つ選択してください"
)
