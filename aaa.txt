-- ==========================================
-- カスタムアトリビュート宣言
-- ==========================================
--global Offset_Attributes


-- ==========================================
-- カスタムアトリビュート定義
-- ==========================================
/*
Offset_Attributes = attributes "OffsetPro"
--redefine:Offset_Attributes
attribID:#(0x6c8c9868, 0x61adb14b)*/






-- ==========================================
-- カスタムモディファイヤ定義
-- ==========================================

plugin modifier Offset_Attributes
    name:"Offset_Attributes"
    classID:#(0x3a4087e9, 0x2c2fdff7)
    category:"My Test"
(
	-- ==========================================
	-- Parameters and member variables
	-- ==========================================	
	
	local callbackHandler = undefined
	local workObj = undefined
	local resultNode = undefined -- オフセット結果のノードを保持
	
	
	
	parameters main rollout:params
	(
		------------ GUI parameter values -----------
		thresh type:#float ui:spn_thresh default:0.1
		iters type:#integer ui:spn_iters default:2
		
		offset_Horizontal  type:#float ui:spn_offset_h default:10.0
		offset_Vertical  type:#float ui:spn_offset_v default:0.0
		
		
		
		----- Max objects(refernces tpo ther nodes) ----
		refResultNode type:#maxObject
		refWorkObj type:#maxObject
		
		bSafeReset type:#boolean default:false -- on clone detection flag to reset maxcObject
		
		
		CA_ID type:#integer default:123456789
	)
	
	
	
	
	-- ==========================================
	-- Utility functions
	-- ==========================================

	-- signed area computation（ to detect inside/outside by sign）
	--fn getSplineArea obj spl =
	--(
	--	local area = 0.0
	--	local n = numKnots obj spl
	--	for i = 1 to n do (
	--		local p1 = getKnotPoint obj spl i
	--		local p2 = if i == n then getKnotPoint obj spl 1 else getKnotPoint obj spl (i + 1)
	--		area += (p1.x * p2.y) - (p2.x * p1.y)
	--	)
	--	area * 0.5
	--)


	--global adaptiveResampleSpline_CornerSafe
	fn adaptiveResampleSpline_CornerSafe obj spl threshold:0.1 iterations:3 =
	(
		
		-- 1. 全ての頂点をBezier化し、ハンドルをノット位置にリセットする
		-- これにより、Corner頂点による「強制的な直線化」を防ぎつつ、形状を維持できる
		local nKnots = numKnots obj spl
		for k = 1 to nKnots do
		(
			local p = getKnotPoint obj spl k
			local curr_knot_type = getKnotType obj spl k
			-- 元々のタイプを問わず、一旦Bezierへ
			--setKnotType obj spl k #bezier
			-- ハンドル長を0にする（ノット位置と一致させる）
			-- これで「見た目」はCornerやLinearセグメントのまま、内部的にサンプリング可能になる
			if curr_knot_type == #corner then
			(
				--setInVec obj spl k p
				--setOutVec obj spl k p
			)
			else if curr_knot_type == #smooth then
			(
				setKnotType obj spl k #bezier		
			)
			
		)
		
		-- 2. セグメントをCurveに変更（サンプリング精度を確保するため）
		local nSegs = numSegments obj spl
		for s = 1 to nSegs do
		(
			setSegmentType obj spl s #curve
		)
		
		--TODO: handle closed curve
		
		-- 3. Do Adaptive refinement
		for i = 1 to iterations do
		(
			local is_closed = isClosed obj spl
			local currentSegs = numSegments obj spl
			local num_knots = numKnots obj spl
			
			local numSegs =  (numSegments obj spl) + (if is_closed then 1 else 0)
			
			--format "iter %: numSegs: %\n" i numSegs
			local j = 0
			while j < numSegs do
			(
				local s = j+1
				local s_next = mod (j+1) (num_knots) + 1
				
				--format "    iter %: seg %\n" j s
				-- 実際のパス上の座標を取得
				local midPointActual = interpBezier3D obj spl s 0.5
				
				
				-- 直線的な中間点を計算
				local p1 = getKnotPoint obj spl s
				local p2 = getKnotPoint obj spl s_next
				--format "    p1: %\n" p1
				--format "    p2: %\n" p2

				local midPointLinear = (p1 + p2) * 0.5
				local dist = distance midPointActual midPointLinear
				
				--format "    midPointLinear: %\n" midPointLinear
				--format "    midPointActual: %\n" midPointActual				
				--format "     suvdivide: %\n" (dist > threshold)
				-- 曲率（歪み）がある場合のみ分割
				if dist > threshold then
				(
					--format "subdividing segment %...\n" s
					refineSegment obj spl s 0.5
					-- refineSegmentで追加された頂点も、自動的に前後のBezier性を引き継ぐ
					j += 2
					numSegs += 1
					num_knots+=1
				)
				else
				(
					j +=1
				)
				--print "----------------------\n"				

			) --end of i loop
			
		) --
		
		/*
		-- 4. クリーンアップ：ハンドル長が0の場所（直線部分）をCornerに戻す
		-- これにより、ユーザーが後でGUIで編集しやすいデータに戻る
		updateShape obj -- 一旦更新して座標を確定
		local finalKnots = numKnots obj spl
		for k = 1 to finalKnots do
		(
			local p = getKnotPoint obj spl k
			local inV = getInVec obj spl k
			local outV = getOutVec obj spl k
			
			-- ハンドルがノットとほぼ同位置ならCornerに戻す
			if (distance p inV < 0.0001) and (distance p outV < 0.0001) do
			(
				setKnotType obj spl k #corner
			)
		)
		*/
		updateShape obj
	)	


	--global OverwriteSplines
	fn OverwriteSplines sourceObj targetObj =
	(
		--print "+++++++++++++++++++++++++++++-----\n"
		
		if (not isValidNode sourceObj) or (not isValidNode targetObj) do return false
		
		
		
		-- Clear existing splines from targetObj
		while (numSplines targetObj) > 0 do deleteSpline targetObj 1
		
		-- Copy spline fr
		local num_splines = numSplines sourceObj
		for s=1 to num_splines do
		(
			-- Add new spline
			local newSplineIdx = addNewSpline targetObj

			-- Copy knots from sourceObj
			is_closed = isClosed sourceObj s
			num_knots = numKnots sourceObj s
				
			for k = 1 to num_knots do
			(	
				local k_seg = mod (k-1) (num_knots-1) + 1 --knot segtype acces index to avoid out of range index.

				local kType = getKnotType sourceObj s k
				local lType = getSegmentType sourceObj s k_seg
				local kPos = getKnotPoint sourceObj s k
				local inVec = getInVec sourceObj s k
				local outVec = getOutVec sourceObj s k
				
				case kType of
				(
					#corner			: addKnot targetObj newSplineIdx kType lType kPos
					default			: addKnot targetObj newSplineIdx kType lType kPos inVec outVec
				)	
				
			)-- end of k loop
			
			-- Apply closed flag
			if is_closed do close targetObj newSplineIdx
			
		) --end of s loop

		updateShape targetObj	
		
	) -- end of OverwriteSplines
		
		

	
	fn getResultNode = 
	(
		--format "  fn getResultNode   %\n" refResultNode
		if refResultNode != undefined and isProperty refResultNode #node then
		(
			--format "getResultNode %\n" refResultNode.node
			refResultNode.node
		)
		else
		(
			--format "getResultNode %\n" undefined
			undefined
		)
	)	
		
	
	fn setResultNode theNode =
	(
        -- nodeTransformMonitorで包むことで、循環参照エラーを回避しつつ参照を維持
        refResultNode = nodeTransformMonitor node:theNode forwardTransformMessages:false
		--format "  fn setResultNode   % %\n" theNode refResultNode
    )	
	
	fn validateResultNode =
	(
		local masterNode =  (refs.dependentNodes this)[1]
		local res = getResultNode()
		
		if res == undefined do
		(
			format "refResultNode does not have item. % %\n" masterNode res
			setResultNode undefined
			return false
		)
		
		if res.parent != masterNode do
		(
			format "incorrect child. resetting refResultNode. % %\n" masterNode res
			setResultNode undefined
		)	
		
	)
	
	

	fn getWorkObj = 
	(
		if refWorkObj != undefined and isProperty refWorkObj #node then
			refWorkObj.node
		else
			undefined
	)	
	
	
	fn setWorkObj theNode = (  refWorkObj = nodeTransformMonitor node:theNode forwardTransformMessages:false )		
	
	
	fn validateWorkObj =
	(
		local masterNode =  (refs.dependentNodes this)[1]
		local res = getWorkObj()
			
		if res == undefined do
		(
			format "refWorkObj does not have item. % %\n" masterNode res
			setWorkObj undefined
			return false
		)
		
		if res.parent != masterNode do
		(
			format "incorrect child. resetting refWorkObj. % %\n" masterNode res
			setWorkObj undefined
		)
	)
	
	
	fn ClearObjects =
	(
		-- Delete working data
		if isValidNode this.workObj do
		(
			delete this.workObj
			this.setWorkObj undefined
		)
		if isValidNode this.resultNode do
		(
			delete this.resultNode
			this.setResultNode undefined
		)
		
		-- Unregister callback handler
		this.callbackHandler = undefined
		gc light:true
	)
	
	
	
	fn SAFE_RESET_MAX_OBJS =
	(
		if this.bSafeReset==true do
		(
			--print "SAFE_RESET_MAX_OBJS()...\n"
			
			setWorkObj undefined
			setResultNode undefined

			this.bSafeReset = false
		)
	)	
	
	
	fn createCurve masterNode =
	(
		--format "createCurve...\n"
		
		if isValidNode workObj do delete workObj
		workObj = splineShape name:(masterNode.name + "_workObj")
		workObj.parent = masterNode
		workObj.isHidden = true
		workObj.isFrozen = true
		setWorkObj workObj
		
		if isValidNode resultNode do delete resultNode
		resultNode = splineShape name:(masterNode.name + "_offset")
		resultNode.parent = masterNode
		setResultNode resultNode
		
		--format "  resultNode: %\n" resultNode
					
		select masterNode
		
	)
	
	
	
	-- メインの計算関数
	fn updateOffset masterNode =
	(
		if not isValidNode masterNode do return false
		
		resultNode = getResultNode()
		workObj = getWorkObj()		
		
		--format "-------------------- updateOffset ----------\n" (isValidNode masterNode) (isValidNode resultNode)
		--format "-resultNode: % %\n" resultNode (getResultNode())
		--format "-workObj: % %\n" workObj (getWorkObj())
		
		if not (isValidNode workObj and isValidNode resultNode) do return false
		

		with redraw off
		(
			-- Reset result node's existing splines
			while (numSplines resultNode) > 0 do deleteSpline resultNode 1
			OverwriteSplines masterNode workObj			
			resultNode.wirecolor = color 255 200 0 -- set color
			
			for s = 1 to (numSplines workObj) do
			(
				adaptiveResampleSpline_CornerSafe workObj s threshold:thresh iterations:iters 
				
				-- 2. 内外判定とオフセット実行
				local finalDist = offset_Horizontal
				
				addNewSpline resultNode
				local finalKnots = numKnots workObj s
				local is_closed = isClosed workObj s
				
				for k = 1 to finalKnots do
				(
					local knot_k = amin k (finalKnots-1)
					--format "% % %\n" finalKnots k knot_k
					local percent = float(k-1) / (if is_closed then finalKnots else (finalKnots-1))
					--percent = amin percent 0.99
					

					local knot_type = getKnotType workObj s k						-- #corner  #smooth   #bezier
					local segment_type = getSegmentType workObj s knot_k 	-- #line       #curve
					
					local p = getKnotPoint workObj s k
					local t = normalize( pathTangent workObj s percent )
					local n = normalize (cross t [0,0,1])
					
					-- Correct extrusion offset according to corner angle --
					local delta = 0.01
					local t_in = normalize( pathTangent workObj s (amax 0.01 (percent-delta)) )
					
					local cos_theta = dot n t_in
					local sin_theta = sqrt (1.0 - cos_theta * cos_theta)
					local offset = n * (finalDist / (amax sin_theta 1.0e-5)) + [0,0,offset_Vertical]
					--local offset = n * finalDist

						
					local inV = (getInVec workObj s k) + offset
					local outV = (getOutVec workObj s k) + offset
					
					--if knot_type != #corner do
					(
						inV = (getInVec workObj s k) + offset
						 outV = (getOutVec workObj s k) + offset
					)
						
						
					case knot_type of
					(
						#corner			: addKnot resultNode s knot_type segment_type (p + offset)
						default			: addKnot resultNode s knot_type segment_type (p + offset) inV outV
					)
					--addKnot resultNode s knot_type segment_type (p + offset)
					--setInVec resultNode s s inV
					--setOutVec resultNode s s outV
					
					
				)-- end of k loop
				
				if isClosed workObj s do close resultNode s
				
			) --end of s loop
			
			updateShape resultNode
			
		)-- end of redraw off
		
		
	) -- end of updateOffset

	
	
	
	rollout params "Offset Pro Controls"
	(
		label lbl_offsets_begin			"---------- Offsets ---------"
		spinner spn_offset_h "Horizontal" range:[-1.0e+9,1.0e+9, 0]
		spinner spn_offset_v "Vertical" range:[-1.0e+9,1.0e+9, 0]
		label lbl_offsets_end			""
		
		label lbl_curve_sampling		"----- Curve Sampling -----"
		spinner spn_thresh "Accuracy: " range:[0.001,10.0,0.1]
		spinner spn_iters "Samples: " range:[0,6,3] type:#integer
		label lbl_curve_sampling_end	""
		
		button btn_create "Create" across: 2
		button btn_del "Remove"

		
		
			
		on spn_offset_h changed val do updateOffset (refs.dependentNodes this)[1]
		on spn_offset_v changed val do updateOffset (refs.dependentNodes this)[1]
			
		on spn_thresh changed val do updateOffset (refs.dependentNodes this)[1]
		on spn_iters changed val do updateOffset (refs.dependentNodes this)[1]
		on btn_del pressed do ( if isValidNode resultNode do delete resultNode if isValidNode workObj do delete workObj )
		
		on btn_create pressed do
		(
			local masterNode = (refs.dependentNodes this)[1] --(refs.dependentNodes (custAttributes.getOwner this))[1]
			createCurve masterNode
			updateOffset masterNode
		)
			

		
			
		-- ロールアウトが開いたとき（修正パネルを選択したとき）にコールバックを開始
		on params open do
		(
			SAFE_RESET_MAX_OBJS()
			
			--resultNode = getResultNode()
			--workObj = getWorkObj()
			
			format "on params open...%\n" (getResultNode())-- refResultNode
		) -- end of on params open
		
		
		on params close do
		(
			print "on params close...\n"

		) -- end of on params close
		
	)
	
	
	
	on create do
	(
		format "on create...\n"
		format "    モディファイヤリスト開いた際に呼び出される\n"
		format "    アタッチした際に呼び出される\n"
		format "...\n"
	)
	

	on postCreate do
	(
		format "on postCreate...\n"
		format "    モディファイヤリスト開いた際に呼び出される\n"
		format "    アタッチした際に呼び出される\n"
		format "...\n"		
	)
	
	
	on load do
	(
		format "on load...\n"
	)
	
	
	on postLoad do
	(
		format "on load...\n"
	)
		
	
	
	on update do
	(
		format "on update...\n"
	)
	
	
	on attachedToNode n do
	(
		format "on attachedToNode...\n"
		format "    アタッチした際に呼び出される\n"
		format "    ペーストした際に呼び出される\n"
	)
	
	
	on detachedFromNode n do
	(
		format "on detachedFromNode...\n"
		format "    親ノードが削除された際に呼び出される\n"
		
		callbackHandler = undefined  --Unregister callback
		gc light:true -- Cleanup memory
		
	)
	
	
	on deleted do
	(
		format "on deleted...\n"
		
	)
	
	
	on clone orig do
	(
		format "on clone ...\n"
		format "    ペーストした際に呼び出される\n"
		
		this.bSafeReset = true
		
		this.workObj = undefined 
		this.resultNode = undefined 
	)
	
	-- モディファイヤのDeleteはcallbacks.addScript で拾う
	
)




-- ==========================================
-- コールバック関数登録
-- ==========================================


global OreOreCloneCallbackID = #OreOreClone


global DestructOffsetCurveModifier
fn DestructOffsetCurveModifier =
(			
	-- Get this modifier
	local me = (callbacks.notificationParam())[2] -- #(node, modifier)
	
	-- Do removal process if THIS CA
	if isKindOf me Offset_Attributes do
	(
		format "PreModifierDeleted......% \n" me.name
		
		local theCA = me --custAttributes.get me  1
		
		-- Delete working data
		--print theCA.workObj
		if isValidNode theCA.workObj do
		(
			delete theCA.workObj
			theCA.setWorkObj undefined
		)
		if isValidNode theCA.resultNode do
		(
			delete theCA.resultNode
			theCA.setResultNode undefined
		)
		
		-- Unregister callback handler
		theCA.callbackHandler = undefined
		gc light:true				
		
		--print "OffsetCurvePreDelet...\n"
	)

)


callbacks.removeScripts id:OreOreCloneCallbackID

callbacks.addScript #preModifierDeleted "DestructOffsetCurveModifier()" id:OreOreCloneCallbackID
--callbacks.addScript #postModifierDeleted "DestructOffsetCurveModifier()" id:OreOreCloneCallbackID

--callbacks.addScript #postModifierAdded "PostModifierAdded()" id:OreOreCloneCallbackID



fn doUpdate ev nodes =
(
	--print "-----------doUpdate --------------.\n"
	
	for h in nodes do
	(
		local masterNode = getAnimByHandle h
		format "doUpdate...    masterNode... %\n" masterNode
		
		for m in masterNode.modifiers do
		(
			if isKindOf m Offset_Attributes do
			(
				format "    ****found Offset_Attributes at ...%\n" m.name
				--format "    ****found OffsetPro at ...%\n" m.name
				--m.OffsetPro.updateOffset masterNode
				m.updateOffset masterNode
				--format "    ****\n"
			)
		)
		
	)-- end of nodes loop
	
	forceCompleteRedraw()
	--print "\n"
)-- end of doUpdate


callbackHandler = undefined  --Unregister callback
gc light:true -- Cleanup memory

callbackHandler = NodeEventCallback mouseup:true geometryChanged:doUpdate topologyChanged:doUpdate





------------------ 選択しているノードが削除された場合に呼び出される関数 --------------
global OnParentNodeDelete
fn OnParentNodeDelete =
(
	format "callbacks script on #nodePreDelete ------------\n"
	local n = callbacks.notificationParam()
	
	if isValidNode n do
	(
		for m in n.modifiers where classOf m==Offset_Attributes do
		(
			--format "Detect Offset_Attributes... Executing destruction...\n"
			m.ClearObjects()
		)
	)
	
)

callbacks.removeScripts id:OreOreCloneCallbackID
callbacks.addScript #nodePreDelete "OnParentNodeDelete()" id:OreOreCloneCallbackID





------------------ 選択していなくてもノードが削除された後で呼び出される関数(Undo/Redoも含む) --------------
--- モディファイヤの破棄処理実行には使えない
global DeleteByNodeEventCallback 
fn DetectDeleteByNodeEventCallback ev nd =
(
	format "On NodeEventCallback:delete...% %\n" ev nd
	for h in nd do
	(
		local obj = getAnimByHandle h -- 削除後なので、モディファイヤも既に消えている
		if isValidNode obj and (findItem obj.modifiers Offset_Attributes != 0) do
		(
			format "DetectDeleteByNodeEventCallback... Found Offset_Attributes.\n"
		)
	)
)

callbackHandler2 = undefined  --Unregister callback
gc light:true -- Cleanup memory
callbackHandler2 = NodeEventCallback deleted:DetectDeleteByNodeEventCallback





/*
-- 選択したスプラインに適用
if selection.count == 1 and superClassOf $ == shape then
(
	undo "SetupOffsetCurveAttrib" on
	(
		local theMod = EmptyModifier()
		theMod.name = "Clone Offset Curve"
		addModifier $ theMod	
		custAttributes.add theMod Offset_Attributes
		--max modify mode
	)
)
else
(
	messageBox "スプラインを1つ選択してください"
)
*/